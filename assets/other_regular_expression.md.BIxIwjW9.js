import{_ as o,c as a,o as c,ag as d}from"./chunks/framework.D-6U7MZ9.js";const s="/n-book/assets/regex_1.RY2hsol1.png",n="/n-book/assets/regex_2.CJhBFgsC.png",r="/n-book/assets/regex_3.Dt9Llmtt.png",l="/n-book/assets/regex_4.GKBIAdCM.png",p="/n-book/assets/regex_5.DCHlpCka.png",t="/n-book/assets/regex_6.DMCstAqB.png",i="/n-book/assets/regex_7.DnL1xOxV.png",h="/n-book/assets/regex_8.DPQErVai.png",g="/n-book/assets/regex_12.BKG6fBt6.png",u="/n-book/assets/regex_13.BKNCtQH3.png",b="/n-book/assets/regex_10.DM92YOsw.png",y="/n-book/assets/regex_11.9CHWGOIv.png",m="/n-book/assets/regex_14.C4dAvghG.png",x="/n-book/assets/regex_9.CjvYAtsD.png",D=JSON.parse('{"title":"正则表达式","description":"","frontmatter":{},"headers":[],"relativePath":"other/regular_expression.md","filePath":"other/regular_expression.md","lastUpdated":1561632709000}'),_={name:"other/regular_expression.md"};function f(A,e,k,C,q,z){return c(),a("div",null,e[0]||(e[0]=[d('<h1 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h1><h2 id="在线工具" tabindex="-1">在线工具 <a class="header-anchor" href="#在线工具" aria-label="Permalink to &quot;在线工具&quot;">​</a></h2><p><a href="https://regex101.com/" target="_blank" rel="noreferrer">regex101</a></p><p>正则的在线工具只推荐regex101，解释正则表达式、显示匹配信息、提供常用语法参考等，足够强大和界面友好。</p><h2 id="基础知识" tabindex="-1">基础知识 <a class="header-anchor" href="#基础知识" aria-label="Permalink to &quot;基础知识&quot;">​</a></h2><p>下面开始正式内容，在 Javascript 中，一个正则表达式以 <code>/</code> 开头和结尾，所以 <code>/hello regexp/</code> 就是一个正则表达式。</p><p>正则中有几个大类需要了解：Flags、Character Sets、Quantifiers、Metacharacters、Special Characters、Groups、Assertion，下面我们一一来讲解。</p><h3 id="flags-标志符或修饰符" tabindex="-1">Flags（标志符或修饰符） <a class="header-anchor" href="#flags-标志符或修饰符" aria-label="Permalink to &quot;Flags（标志符或修饰符）&quot;">​</a></h3><p>Flags 写在结束的<code>/</code>之后，可以影响整个正则表达式的匹配行为。常见的 flags 有：</p><ol><li><code>g</code>：全局匹配（global）；正则表达式默认只会返回第一个匹配结果，使用标志符 g 则可以返回所有匹配。</li><li><code>i</code>：忽略大小写（case-insensitive）；在匹配时忽略英文字母的大小写。</li><li><code>m</code>：多行匹配（multiline）；将开始和结束字符（^和$）视为在多行上工作，即分别匹配每一行（由 \\n 或 \\r 分割）的开始和结束，而不只是只匹配整个输入字符串的最开始和最末尾处。</li></ol><p>所有的 flags 都打上的话，那就是<code>/^*$/gimsuy</code>： <img src="'+s+'" alt="regex_1"></p><h3 id="character-sets-字符集合" tabindex="-1">Character Sets（字符集合） <a class="header-anchor" href="#character-sets-字符集合" aria-label="Permalink to &quot;Character Sets（字符集合）&quot;">​</a></h3><p>用于匹配字符集合中的任意一个字符。</p><ol><li><code>[xyz]</code>：匹配 <code>x</code>或<code>y</code>或<code>z</code>。</li><li><code>[^xyz]</code>：补集，匹配除了 <code>x</code> <code>y</code> <code>z</code>的其他字符。</li><li><code>[a-z]</code>：匹配从 <code>a</code> 到 <code>z</code> 的任意字符。</li><li><code>[^a-n]</code>：补集，匹配除了 <code>a</code> 到 <code>n</code> 的其他字符。</li><li><code>[A-Z]</code>：匹配从 <code>A</code> 到 <code>Z</code> 的任意字符。</li><li><code>[0-9]</code>：匹配从 <code>0</code> 到 <code>9</code> 的任意数字。</li></ol><p>匹配所有的字母和数字可写成：<code>/[a-zA-Z0-9]/</code> 或者 <code>/[a-z0-9]/i</code>。</p><h3 id="quantifiers-量词" tabindex="-1">Quantifiers (量词) <a class="header-anchor" href="#quantifiers-量词" aria-label="Permalink to &quot;Quantifiers (量词)&quot;">​</a></h3><p>使用 Quantifiers 来实现重复匹配。</p><ol><li><code>{n}</code>：匹配 <code>n</code> 次。</li><li><code>{n,m}</code>：匹配 <code>n到m</code> 次。</li><li><code>{n,}</code>：匹配 <code>&gt;=n</code> 次，即<code>大于n</code>次。</li><li><code>?</code>：匹配 <code>0 || 1</code> 次，即 <code>0或者1</code> 次。</li><li><code>*</code>：匹配 <code>&gt;=0</code> 次，等价于 <code>{0,}</code>。</li><li><code>+</code>：匹配 <code>&gt;=1</code> 次，等价于 <code>{1,}</code>。</li></ol><p>如字段<code>abczzzzzzzxyabcabcabc</code>，使用<code>/z*xy/gi</code>，会匹配出<code>zzzzzzzxy</code>；</p><p>使用<code>/z{0,2}xy/gi</code>，会匹配出<code>zzxy</code>；</p><h3 id="metacharacters-元字符" tabindex="-1">Metacharacters（元字符） <a class="header-anchor" href="#metacharacters-元字符" aria-label="Permalink to &quot;Metacharacters（元字符）&quot;">​</a></h3><p>在正则表达式中有一些具有特殊含义的字母，被称为元字符，简言之，元字符就是描述字符的字符，它用于对字符表达式的内容、转换及各种操作信息进行描述。</p><p>常见的元字符有：</p><ol><li><code>\\d</code>：匹配任意数字，等价于 <code>[0-9]</code>。</li><li><code>\\D</code>：匹配任意非数字字符；<code>\\d</code> 的补集。</li><li><code>\\w</code>：匹配任意基本拉丁字母表中的字母和数字，以及下划线；等价于 <code>[A-Za-z0-9_]</code>。</li><li><code>\\W</code>：匹配任意非基本拉丁字母表中的字母和数字，以及下划线；<code>\\w</code> 的补集。</li><li><code>\\s</code>：匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。</li><li><code>\\S</code>：匹配一个非空白符；<code>\\s</code> 的补集。</li><li><code>\\b</code>：匹配一个零宽单词边界，如一个字母与一个空格之间；例如，<code>/\\bno/</code>匹配 <code>at noon</code> 中的 <code>no</code>，<code>/ly\\b/</code> 匹配 <code>possibly yesterday.</code> 中的 <code>ly</code>。</li><li><code>\\B</code>：匹配一个零宽非单词边界，如两个字母之间或两个空格之间；例如，<code>/\\Bon/</code> 匹配 <code>at noon</code> 中的 <code>on</code>，<code>/ye\\B/</code> 匹配 <code>possibly yesterday.</code> 中的 <code>ye</code>。</li><li><code>\\t</code>：匹配一个水平制表符（tab)。</li><li><code>\\n</code>：匹配一个换行符（newline)。</li><li><code>\\r</code>：匹配一个回车符（carriage return)。</li></ol><h4 id="理解-b-零宽单词边界" tabindex="-1">理解<code>\\b 零宽单词边界</code> <a class="header-anchor" href="#理解-b-零宽单词边界" aria-label="Permalink to &quot;理解`\\b 零宽单词边界`&quot;">​</a></h4><p>我们看以下的匹配： <img src="'+n+'" alt="regex_2"></p><p>上图中，紫红色竖线表示的位置就是零宽单词边界（Matches a zero-width word boundary），说白了，就是一个字母的两侧是否有空格，我们输入内容，就知道匹配的是什么了： <img src="'+r+`" alt="regex_3"></p><h3 id="special-characters-特殊字符" tabindex="-1">Special Characters (特殊字符) <a class="header-anchor" href="#special-characters-特殊字符" aria-label="Permalink to &quot;Special Characters (特殊字符)&quot;">​</a></h3><p>正则中存在一些特殊字符，它们不会按照字面意思进行匹配，而有特殊的意义，比如前文讲过用于量词的<code>?</code>、<code>*</code>、<code>+</code>。</p><p>其他常见的特殊字符有：</p><ol><li><code>\\</code>：转义字符，可以将普通字符转成特殊字符。比如<code>\\w</code>；也可以将特殊字符转成字面意思，比如 <code>\\+</code> 匹配 <code>+</code>。</li><li><code>.</code>：匹配任意单个字符，但是换行符除外：<code>\\n</code>, <code>\\r</code>, <code>\\u2028</code> 或 <code>\\u2029</code>；在字符集中<code>[.]</code>，无特殊含义，即表示 <code>.</code> 的字面意思。</li><li><code>|</code>：替换字符（alternate character），匹配 <code>|</code> 前或后的表达式。比如需要同时匹配 <code>bear</code> 和 <code>pear</code>，可以使用 <code>/(b|p)ear/</code> 或者 <code>/bear|pear/</code>；但是不能用 <code>/b|pear/</code>，该表达式只能匹配 <code>b</code> 和 <code>pear</code>。</li><li><code>^</code>：匹配输入的开始。比如，<code>/^A/</code> 不匹配 <code>an Apple</code> 中的 <code>A</code>，但匹配 <code>An apple</code> 中的 <code>A</code>。</li><li><code>$</code>：匹配输入的结尾。比如，<code>/t$/</code> 不匹配 <code>eater</code> 中的 <code>t</code>，但匹配 <code>eat</code> 中的 <code>t</code>。</li></ol><p><code>^</code> 和 <code>$</code> 在表单验证时常需要使用，因为需要验证从开始到结尾的一个完整输入，而不是匹配输入中的某一段。</p><h3 id="groups-分组" tabindex="-1">Groups（分组） <a class="header-anchor" href="#groups-分组" aria-label="Permalink to &quot;Groups（分组）&quot;">​</a></h3><ol><li><code>(xyz)</code>：捕获分组（Capturing Group），匹配并捕获匹配项；例如，<code>/(foo)/</code> 匹配且捕获 <code>foo bar.</code> 中的 <code>foo</code>。</li></ol><p>被匹配的子字符串可以在结果数组的元素 <code>[1], ..., [n]</code> 中找到，或在被定义的 RegExp 对象的属性 <code>$1, ..., $9</code> 中找到。</p><ol start="2"><li><code>(?:xyz)</code>：非捕获分组（Non-capturing Group），匹配但不会捕获匹配项；匹配项不能再次被访问到。</li><li><code>\\n</code>：n 是一个正整数，表示反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串；例如，<code>/apple(,)\\sorange\\1/</code> 匹配 <code>apple, orange, cherry, peach.</code> 中的 <code>apple, orange,</code>。</li></ol><hr><h4 id="我们来理解一下-非捕获分组-non-capturing-group-是什么意思" tabindex="-1">我们来理解一下：“非捕获分组（Non-capturing Group）”是什么意思？ <a class="header-anchor" href="#我们来理解一下-非捕获分组-non-capturing-group-是什么意思" aria-label="Permalink to &quot;我们来理解一下：“非捕获分组（Non-capturing Group）”是什么意思？&quot;">​</a></h4><p>先执行如下代码：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki everforest-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E69875;">var</span><span style="color:#D3C6AA;"> string </span><span style="color:#E69875;">=</span><span style="color:#DBBC7F;"> &quot;at noonfooasfodsoo&quot;</span><span style="color:#D3C6AA;">;</span></span>
<span class="line"><span style="color:#E69875;">var</span><span style="color:#D3C6AA;"> regex </span><span style="color:#E69875;">=</span><span style="color:#DBBC7F;"> /</span><span style="color:#D3C6AA;">(</span><span style="color:#DBBC7F;">foo</span><span style="color:#D3C6AA;">)</span><span style="color:#DBBC7F;">/</span><span style="color:#E67E80;">gi</span><span style="color:#D3C6AA;">;</span></span>
<span class="line"><span style="color:#E69875;">var</span><span style="color:#D3C6AA;"> c1 </span><span style="color:#E69875;">=</span><span style="color:#D3C6AA;"> regex</span><span style="color:#859289;">.</span><span style="color:#A7C080;">exec</span><span style="color:#D3C6AA;">(string);</span></span>
<span class="line"><span style="color:#E69875;">var</span><span style="color:#D3C6AA;"> regex1 </span><span style="color:#E69875;">=</span><span style="color:#DBBC7F;"> /</span><span style="color:#D3C6AA;">(?:</span><span style="color:#DBBC7F;">foo</span><span style="color:#D3C6AA;">)</span><span style="color:#DBBC7F;">/</span><span style="color:#E67E80;">gi</span><span style="color:#D3C6AA;">;</span></span>
<span class="line"><span style="color:#E69875;">var</span><span style="color:#D3C6AA;"> c2 </span><span style="color:#E69875;">=</span><span style="color:#D3C6AA;"> regex1</span><span style="color:#859289;">.</span><span style="color:#A7C080;">exec</span><span style="color:#D3C6AA;">(string);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>看看输出结果<code>c1</code>和<code>c2</code>值的区别： <img src="`+l+'" alt="regex_4"></p><p>返回的数组中少了<code>[1]</code>的内容，我们到 regex101 上去也看看区别： <img src="'+p+'" alt="regex_5"><img src="'+t+'" alt="regex_6"> 所以使用<code>(?:xyz)</code>，意思是匹配并但不会捕获匹配项到 Group 中。</p><hr><h4 id="我们再来理解什么是-反向引用-back-reference" tabindex="-1">我们再来理解什么是“反向引用（back reference）” <a class="header-anchor" href="#我们再来理解什么是-反向引用-back-reference" aria-label="Permalink to &quot;我们再来理解什么是“反向引用（back reference）”&quot;">​</a></h4><p>如上例，<code>/apple(,)\\sorange\\1/</code>中的<code>\\1</code>指的其实就是<code>(,)</code>，这个表达式等同的写法是<code>/apple(,)\\sorange(,)/</code><img src="'+i+'" alt="regex_7"></p><p>我们试试<code>\\2</code>，也就是等价于左数第二个括号中的内容，看看匹配到的内容，我们在文本内容中再多加一个<code>,</code>： <img src="'+h+'" alt="regex_8"></p><h3 id="assertion-断言" tabindex="-1">Assertion（断言） <a class="header-anchor" href="#assertion-断言" aria-label="Permalink to &quot;Assertion（断言）&quot;">​</a></h3><ol><li><code>x(?=y)</code>：仅匹配被 y 跟随的 x，这个也被称为：“先行断言”/“正向肯定查找”</li></ol><p>例如，<code>/bruce(?=wayne)/</code>，如果<code>bruce</code>后面跟着<code>wayne</code>，则匹配<code>bruce</code>。</p><p><code>/bruce(?=wayne|banner)/</code>，如果<code>bruce</code>后面跟着<code>wayne</code>或者<code>banner</code>，则匹配<code>bruce</code>。</p><p><code>wayne</code> 和 <code>banner</code> 都不会在匹配结果中出现。</p><ol start="2"><li><code>(?&lt;=y)x</code>：匹配&#39;x&#39;仅当&#39;x&#39;前面是&#39;y&#39;，这个也被称为：“后行断言”</li></ol><p>例如，<code>(?&lt;=bruce)wayne</code>，如果<code>wayne</code>前面是<code>bruce</code>，则匹配<code>wayne</code>。 <img src="'+g+'" alt="regex_12"></p><p><code>/(?&lt;=bruce|banner)wayne/</code>，如果<code>wayne</code>前面是<code>bruce</code>或者<code>banner</code>，则匹配<code>wayne</code>。 <img src="'+u+'" alt="regex_13"></p><p><code>wayne</code> 和 <code>banner</code> 都不会在匹配结果中出现。</p><ol start="3"><li><code>x(?!y)</code>：仅匹配不被 y 跟随的 x，这个也被称为：“正向否定查找”</li></ol><p>例如，<code>/\\d+(?!\\.)/</code> 只会匹配不被 &quot;.&quot; 跟随的数字。</p><p><code>/\\d+(?!\\.)/.exec(&#39;3.141&#39;)</code> 匹配 <code>141</code>，而不是 <code>3.141</code></p><h2 id="非贪婪匹配-non-greedy" tabindex="-1">非贪婪匹配（non-greedy） <a class="header-anchor" href="#非贪婪匹配-non-greedy" aria-label="Permalink to &quot;非贪婪匹配（non-greedy）&quot;">​</a></h2><p>默认情况下，正则表达式的量词<code>*</code>、<code>+</code>、<code>？</code>、<code>{}</code>，都是进行贪婪匹配（greedy），即匹配尽可能多的字符。</p><p>非贪婪匹配，即匹配尽量少的字符(matching the fewest possible characters)。</p><p>怎么理解呢？ 例如这么一段话：<code>The reading of all good books is like a conversation with the finest men of past centuries.</code></p><p>使用<code>/.+\\s/</code>匹配，<code>.</code>可以匹配任意字符，而<code>+</code>表示匹配 1 次或者多次，默认是贪婪匹配，所以会匹配到了最后一个空格符才结束。 <img src="'+b+'" alt="regex_10"></p><p>而当我们在量词<code>*</code>、<code>+</code>、<code>？</code>、<code>{}</code>后面紧跟着一个<code>?</code>，就可以实现非贪婪匹配。</p><p>例如<code>/.+?\\s/</code>，匹配到第一个空格符就会结束： <img src="'+y+`" alt="regex_11"></p><h2 id="多行匹配" tabindex="-1">多行匹配 <a class="header-anchor" href="#多行匹配" aria-label="Permalink to &quot;多行匹配&quot;">​</a></h2><p>例如下面一段文字：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki everforest-dark vp-code" tabindex="0"><code><span class="line"><span>May God bless and keep you always,</span></span>
<span class="line"><span>may your wishes all come true,</span></span>
<span class="line"><span>may you always do for others</span></span>
<span class="line"><span>and let others do for you.</span></span>
<span class="line"><span>may you build a ladder to the stars</span></span>
<span class="line"><span>and climb on every rung,</span></span>
<span class="line"><span>may you stay forever young,</span></span>
<span class="line"><span>forever young, forever young,</span></span>
<span class="line"><span>May you stay forever young.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如何匹配以 forever 开头的那句歌词<code>forever young, forever young</code>呢？</p><p>写<code>/^forever.+/</code>是错误的，因为<code>^</code>匹配的整个字符串的开始，而是不是每一行的开始。</p><p>所以指定<code>m</code>选项，即可支持多行匹配，这时<code>^</code>和<code>$</code>匹配的是每一行的开始和结束，因此正确的正则表达式是<code>/^forever.+/m</code>： <img src="`+m+'" alt="regex_14"></p><h2 id="应用例子" tabindex="-1">应用例子 <a class="header-anchor" href="#应用例子" aria-label="Permalink to &quot;应用例子&quot;">​</a></h2><h3 id="_1-匹配手机号码" tabindex="-1">1. 匹配手机号码 <a class="header-anchor" href="#_1-匹配手机号码" aria-label="Permalink to &quot;1. 匹配手机号码&quot;">​</a></h3><p>匹配<code>1(3/4/5/7/8)开头的11位数字</code>。</p><ol><li>以 1 开头：<code>/^1/</code></li><li>第 2 位为 3、4、5、7、8 中的一个：<code>/[34578]/</code> 或 <code>/(3|4|5|7|8)/</code></li><li>剩余 3-11 位均为数字，并以数字结尾：<code>/\\d{9}$/</code></li></ol><p>组合起来即为 <code>/^1[34578]\\d{9}$/</code> 或 <code>/^1(3|4|5|7|8)\\d{9}$/</code>，因为使用捕获括号存在性能损失，所以推荐使用第一种写法。</p><h3 id="_2-匹配电子邮件" tabindex="-1">2. 匹配电子邮件 <a class="header-anchor" href="#_2-匹配电子邮件" aria-label="Permalink to &quot;2. 匹配电子邮件&quot;">​</a></h3><p>标准的电子邮件组成为 <code>&lt;yourname&gt;@&lt;domain&gt;.&lt;extension&gt;&lt;optional-extension&gt;</code>。</p><p>每部分的格式标准为：</p><ol><li><code>yourname</code>：任意英文字母（a-z/A-Z）、数字（0-9）、下划线（_）、英文句点（.）、连字符（-），长度大于 0</li><li><code>domain</code>：任意英文字母（a-z/A-Z）、数字（0-9）、连字符（-），长度大于 0</li><li><code>extension</code>：任意英文字母（a-z/A-Z），长度 2-8</li><li><code>optional-extension</code>：&quot;.&quot;开头，后面跟任意英文字母（a-z/A-Z），长度 2-8，可选</li></ol><p>每部分的正则表达式为：</p><ol><li><code>yourname</code>：<code>/[a-z\\d._-]+/</code></li><li><code>domain</code>：<code>/[a-z\\d-]+/</code></li><li><code>extension</code>：<code>/[a-z]{2,8}/</code></li><li><code>optional-extension</code>：<code>/(\\.[a-z]{2,8})?/</code></li></ol><p>组合起来形成最后的正则表达式：<code>/^([a-z\\d._-]+)@([a-z\\d-]+)\\.([a-z]{2,8})(\\.[a-z]{2,8})?$/ig</code>；为了增加可读性可以将每部分用<code>()</code>包起来，并不要忘记起始和结束符<code>^$</code>。</p><p><img src="'+x+'" alt="regex_9"></p><p>掌握上面所说的这些内容，日常使用的正则基本不会有什么问题了。</p><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h2><p><a href="https://segmentfault.com/a/1190000018489883" target="_blank" rel="noreferrer">segmentfault</a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noreferrer">MDN</a></p>',87)]))}const w=o(_,[["render",f]]);export{D as __pageData,w as default};
